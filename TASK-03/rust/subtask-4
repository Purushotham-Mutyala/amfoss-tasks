use std::fs::File;
use std::io::{self, BufRead, Write};
use std::path::Path;

fn main() -> io::Result<()> {
    
    let input_path = "input.txt";
    let output_path = "output.txt";

    
    let n = read_number_from_file(input_path)?;

   
    let diamond_pattern = generate_diamond(n);

   
    write_to_file(output_path, &diamond_pattern)?;

    println!("Diamond pattern written to '{}'.", output_path);

    Ok(())
}


fn read_number_from_file(file_path: &str) -> io::Result<usize> {
    let file = File::open(file_path)?;
    let reader = io::BufReader::new(file);
    let mut lines = reader.lines();
    let line = lines.next().ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "No line found"))??;
    let number: usize = line.trim().parse().map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "Invalid number"))?;
    Ok(number)
}


fn generate_diamond(n: usize) -> String {
    let mut pattern = String::new();

    if n == 0 {
        return pattern;
    }

    
    for i in 0..n {
        let spaces = " ".repeat(n - i - 1);
        let stars = "*".repeat(2 * i + 1);
        pattern.push_str(&format!("{}{}\n", spaces, stars));
    }

   
    for i in (0..n - 1).rev() {
        let spaces = " ".repeat(n - i - 1);
        let stars = "*".repeat(2 * i + 1);
        pattern.push_str(&format!("{}{}\n", spaces, stars));
    }

    pattern
}


fn write_to_file(file_path: &str, content: &str) -> io::Result<()> {
    let mut file = File::create(file_path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}
